import React, { useEffect, useRef, useState } from 'react';
import 'mapbox-gl/dist/mapbox-gl.css';
import mapboxgl from 'mapbox-gl'
import ReactMapboxGl, { Layer, Feature } from 'react-mapbox-gl';
import * as THREE from 'three'
import model from '../markerr.gltf'
import matcap from './matcap4.png'
import globalTb from 'threebox-plugin';
import "threebox-plugin/dist/threebox.css"
import "threebox-plugin/examples/css/threebox.css"
import SearchBox from './SearchBox';
import axios from '../axios';

const Threebox = globalTb.Threebox

const Mapbox = ReactMapboxGl({
    accessToken:
        'pk.eyJ1Ijoic2hlbnplbjY0IiwiYSI6ImNrbnNzaWg0ODExZ2oycW8xa2Jkc2FmeWwifQ.yFDqLEHzuH3qZLAgqt33MA', 
});
 
const matc = new THREE.TextureLoader().load(matcap)


let minZoom = 12;
let mapConfig = {
			ALL: { center: [-7.565357, 33.560155,0], zoom: 16.25, pitch: 45, bearing: 0 },
			names: {
				compositeSource: "composite",
				compositeSourceLayer: "building",
				compositeLayer: "3d-buildings"
			}
		}


const geometry = new THREE.PlaneBufferGeometry(30,50,12);


const Maps = () => {
    const [pitch, setPitch] = useState(40)
    const [coords, setCoords] = useState([])
    const [trajets, setTrajets] = useState([])
    const [arr, setArr] = useState([])
    const [mapp,setMap] = useState(null)
    // const [school,setCurrSchool] = useState("") 
    const mapContainer = useRef()

    
  
    const handleStyleLoad = (map) => {
        setMap(map)  //
        // map.addLayer(createCompositeLayer())  
        map.addLayer({
            id: 'custom_layer',
            type: 'custom',
            renderingMode: '3d',
            onAdd: function (map, mbxContext) {
                
                // instantiate threebox
                window.tb = new Threebox(
                    map,
                    mbxContext,
                    {
                        defaultLights: true,
                        enableSelectingObjects: true,
                        enableSelectingFeatures: true, //change to false to disable fill-extrusion features selection
                        multiLayer: true,
                        antialias:true,      
                        realSunlight: true,
                        enableSelectingObjects: true, //enable 3D models over/selectionn
                        enableTooltips: true // enable default tooltips on fill-extrusion and 3D models 
                 
                    }
                );
                
                let options = {
                    type: 'gltf', 
                    obj: model, //model url
                    units: 'meters', //units in the default values are always in meters
                    scale: 13,
                    rotation: { x: 90, y: 180, z: 0 }, //default rotation
                    anchor: 'center',
                    // enableTooltips:true
                }
                arr.forEach((cube, i) => {
                    const lat = trajets[i].depart[0]
                    const long = trajets[i].depart[1]

                    cube.setCoords([long, lat]);
                    
                    cube.rotation.x =  -Math.PI/2
                     cube.position.z +=2
                    cube.position.x -=0.42
                    cube.position.y +=0.06
               
                    window.tb.add(cube);
                    window.tb.loadObj(options, function (model) {
                        


                        model.setCoords([long,lat]);
                       
                        model.castShadow = true
                        window.tb.world.add(model);
                    });
                })
               // SCHOOLS
                schoolsLayer()
                // LINES
                trajets.forEach((trajet)=>{
                   const singleLine = drawLine(trajet.depart.reverse(),trajet.destination.coordinate.reverse())
                   const lineMesh= window.tb.line({
                        geometry: singleLine,
                        color: '#c02b2b',
                        width: 2
                    })
                    window.tb.world.add(lineMesh)
                })

                // LABEL
                // const labelObj= window.tb.tooltip({
                //     cssClass:'label',
                //     text:'Lorem it amet adipisicing elit. Ratione repellendus modi quae consequatur perferendis? Atque neque earum quas laudantium, cum nesciunt aliquid quisquam, harum facere commodi maiores qui reiciendis veritatis.'
                // })
                // labelObj.setCoords([-7.565357, 33.560155])
                // window.tb.world.add(labelObj)
            
               // INIT
                window.tb.defaultLights()
                window.tb.createSkyLayer()
                window.tb.getSunSky(new Date())
            },

            render: function (gl, matrix) {
                window.tb.update();
            }
        })
        //      
    }
    
  const loadData = async () => {
        try {
            const data = await axios.get("/allSchools")
            setCoords(data.data) 
        } catch (error) {
            console.log(error)
        }

    }
    
    const loadTrajects = async () => {
        try {
            const data = await axios.get("/allTrajets")
            setTrajets(data.data) 
        } catch (error) {
            console.log(error)
        }
    }
    const schoolsLayer = ()=>{
       const schoolMaterial = new THREE.MeshMatcapMaterial({
           matcap:matc
       })
        let options = {
            type: 'gltf', 
            obj: model, //model url
            units: 'meters', //units in the default values are always in meters
            scale: 20,
            rotation: { x: 90, y: 180, z: 0 }, //default rotation
            anchor: 'center',
            // enableTooltips:truee
        }
       coords.forEach((school,i)=>{
        const lat = school.coordinate[0]
        const long = school.coordinate[1]
        window.tb.loadObj(options, function (model) {
                        
            model.setCoords([long,lat]);
            model.traverse((mesh)=>{
                if(mesh.isMesh){
                    mesh.material = schoolMaterial
                }
            })
            model.addHelp(school.surnom.toUpperCase(),school.surnom,true,model.center,1,"label")
            model.castShadow = true
            window.tb.world.add(model);
        });
       })
    }

    const drawLine = (start,destination)=>{
        var line = new Array();
        var maxElevation = Math.pow(Math.abs(destination[0]*destination[1]), 0.5)*10 ;
        var arcSegments = 25;
    
        for (var l = 0; l<=arcSegments; l++){
            
            var waypoint = [lerp(start[0],destination[0],l/arcSegments),lerp(start[1],destination[1],l/arcSegments)]
    
            var waypointElevation = Math.sin(Math.PI*l/arcSegments) * maxElevation;
            
            waypoint.push(waypointElevation);
            line.push(waypoint);
        }
        return line
    }

    const generateArr = ()=>{

        const materials = []

        trajets.forEach((trajet,i)=>{  
                    const cnv = document.createElement('canvas')
                    cnv.width = 1024  
                    cnv.height = 1024
                    const ctx = cnv.getContext('2d')
                    ctx.save()
                    ctx.fillStyle = '#dfdfdf'
                    ctx.fillRect(0, 0, cnv.width, cnv.height);
                    // ctx.textAlign = "center"
                    // Lorem  sit amet hhi  similique temporibus phi0 consectetur obcaecati, ullam nisi nesciunt autem vel adipisci voluptas sit beatae quaerat dolore natus repellat enim.
                    ctx.font = "6.5rem sans-serif";
                    ctx.fillStyle='#080077'
                    ctx.fillText(`Debut du Trajet`, cnv.width/5,cnv.height/9)

                    ctx.font = "7.5em sans-serif";
                    ctx.textBaseline = "center";
                    ctx.maxWidth =cnv.width;
                    ctx.fillStyle='#252020'
                    ctx.fillText("-Destination:", cnv.width/8,cnv.height/4)

                    ctx.fillStyle='#252020'
                    ctx.fillText(`${trajets[i].destination.surnom} üè≥`, cnv.width/8,cnv.height/2.8)
                    ctx.fillStyle='#252020'
                    ctx.font = "6.2em sans-serif";
                    ctx.fillText(`-Prix Du trajet: ${trajets[i].prix ? trajets[i].prix : "--" }dh `, cnv.width/8,cnv.height/2)
                    ctx.fillText(`-Date Du Trajet: ${trajets[i].date ? trajets[i].date : "--" }dh `, cnv.width/8,cnv.height/1.65)
                    ctx.fillText(`-Nombre de passagers: ${trajets[i].passagers.length} `, cnv.width/8,cnv.height/1.4)
                    ctx.restore()
    
    
                    const texture = new THREE.CanvasTexture(cnv)
    
                    const material =new THREE.ShaderMaterial({
                        vertexShader : `
                        varying vec2 vUv;  
                        void main (){
                            vec4 modelPosition = modelMatrix * vec4(position,1.0);
                            
                            vec4 viewPosition = viewMatrix * modelPosition;
                            vec4 projectedPosition = projectionMatrix * viewPosition;
                        
                            gl_Position = projectedPosition;
                            vUv = uv;
                        }
                        `,
                        fragmentShader : `
                        uniform sampler2D uTexture;
                        varying vec2 vUv;
                        void main()
                        {
                            vec4 textureColor = texture2D(uTexture,vec2(vUv.x,vUv.y));
                            gl_FragColor = vec4(textureColor.xyz,1.0);
                        }
                        ` ,
                        uniforms:{
                            uTexture: { value: texture }
                        }
                    })
                    // const material = new THREE.MeshStandardMaterial({
                    //     map:texture
                    // })
                    materials.push(material)
                    
                })
        
        const arrr = []
        for (let i = 0; i < trajets.length; i++) {

            let cube1 = new THREE.Mesh(geometry, materials[i])
           
            cube1 = window.tb.Object3D({ obj: cube1, units: 'meters' });
            
            cube1.rotation.z= Math.PI
            arrr.push(cube1)
        }
        
        return arrr
    }
    useEffect(() => {
      loadData()
      loadTrajects()
        setArr(generateArr())
        

    }, [])
    let prevZoom = 18;
    const handleZoom = (e) => {
        const currZoom = e.getZoom();
        const scale = clampZoom(prevZoom, currZoom);
        prevZoom = currZoom
        const root = document.documentElement
        const currScale = root?.style.getPropertyValue('--markerScale')
        root?.style.setProperty("--markerScale",currScale+scale)
       if(currZoom < 10){
        root?.style.setProperty("--markerScale",0.3)
       }
    }
    // Lorem ipsum elit. reiciendis veritatis fugit a fugiat excepturi, sit enim accusantium illo voluptas perferendis nobis.
    return (
        <div className='mapContainer' ref={mapContainer}>
            <SearchBox map={mapp} />
         
            <Mapbox
            
                style="mapbox://styles/mapbox/navigation-night-v1"
                containerStyle={{
                    height: '100vh',
                    width: '100vw'
                }}
                onClick={(map, e) => {
                    console.log(e.lngLat)
                }}
                center={[-7.565357, 33.560155]}
                antialias={true}
                pitch={[pitch]}
                onStyleLoad={handleStyleLoad}
                zoom={[18]}
                onZoom={handleZoom}
            >
                {/* <Layer type="symbol" id="marker" layout={{ 'icon-image': 'marker-15' }}>
                <Feature coordinates={[148.981427, -35.398307]} />
            </Layer> */}
            </Mapbox>;
        </div>
    )
}



function lerp(value1, value2, amount) {
    amount = amount < 0 ? 0 : amount;
    amount = amount > 1 ? 1 : amount;
    return value1 + (value2 - value1) * amount;
}


function onObjectMouseOver(e) {
    console.log("ObjectMouseOver: " + e.detail.name);
}

//actions to execute onObjectMouseOut
function onObjectMouseOut(e) {
    console.log("ObjectMouseOut: " + e.detail.name);
}

function createCompositeLayer() {
    let layer = {
        'id': mapConfig.names.compositeLayer,
        'source': mapConfig.names.compositeSource,
        'source-layer': mapConfig.names.compositeSourceLayer,
        'filter': ['==', 'extrude', 'true'],
        'type': 'fill-extrusion',
        'minzoom': minZoom,
        'paint': {
            'fill-extrusion-color':
                [
                    'case',
                    ['boolean', ['feature-state', 'select'], false],
                    "lightgreen",
                    ['boolean', ['feature-state', 'hover'], false],
                    "lightblue",
                    '#343242'
                ],

            // use an 'interpolate' expression to add a smooth transition effect to the
            // buildings as the user zooms in
            'fill-extrusion-height': [
                'interpolate',
                ['linear'],
                ['zoom'],
                minZoom,
                0,
                minZoom + 0.05,
                ['get', 'height']
            ],
            'fill-extrusion-base': [
                'interpolate',
                ['linear'],
                ['zoom'],
                minZoom,
                0,
                minZoom + 0.05,
                ['get', 'min_height']
            ],
            'fill-extrusion-opacity': 0.9
        }
    };
    return layer;
}



const clampZoom = (prevZoom, currZoom) => {
    let scale = 0.1
    // if (currZoom > 15) {
    //     scale = 0.001
    // } else {
    //     scale = 0.0297
    // }

    if (prevZoom < currZoom) {
        scale *= -1
    }

    return scale

}


export default Maps
